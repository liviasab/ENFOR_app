var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "fs-extra", "path", "find-package-json", "child_process", "@clack/prompts", "util", "simple-git"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cloneComponentRepo = exports.pullComponentRepo = exports.checkIfFolderExists = exports.getPackageJsonPath = exports.dashToPascal = exports.pascalToDash = exports.addIndexFile = exports.installDependencies = exports.getConfigComponentPath = void 0;
    const fs_extra_1 = __importDefault(require("fs-extra"));
    const path_1 = __importDefault(require("path"));
    const find_package_json_1 = __importDefault(require("find-package-json"));
    const child_process_1 = require("child_process");
    const prompts_1 = require("@clack/prompts");
    const util_1 = __importDefault(require("util"));
    const simple_git_1 = __importDefault(require("simple-git"));
    const stat = util_1.default.promisify(fs_extra_1.default.stat);
    const currDir = process.cwd();
    const getPackageJsonPath = () => {
        var f = (0, find_package_json_1.default)(currDir);
        return f.next().filename || '';
    };
    exports.getPackageJsonPath = getPackageJsonPath;
    const rootPackageJsonPath = getPackageJsonPath();
    const projectRootPath = path_1.default.dirname(rootPackageJsonPath);
    const detectLockFile = () => {
        const packageLockPath = path_1.default.join(projectRootPath, 'package-lock.json');
        const yarnLockPath = path_1.default.join(projectRootPath, 'yarn.lock');
        const pnpmLockPath = path_1.default.join(projectRootPath, 'pnpm-lock.yaml');
        if (fs_extra_1.default.existsSync(packageLockPath)) {
            return 'npm';
        }
        else if (fs_extra_1.default.existsSync(yarnLockPath)) {
            return 'yarn';
        }
        else if (fs_extra_1.default.existsSync(pnpmLockPath)) {
            return 'pnpm';
        }
        else {
            return null;
        }
    };
    const promptVersionManager = () => __awaiter(void 0, void 0, void 0, function* () {
        const packageManager = yield (0, prompts_1.select)({
            message: 'No lockfile detected. Please select a package manager to install dependencies:',
            options: [
                { value: 'npm', label: 'npm', hint: 'recommended' },
                { value: 'yarn', label: 'yarn' },
                { value: 'pnpm', label: 'pnpm' },
            ],
        });
        if ((0, prompts_1.isCancel)(packageManager)) {
            (0, prompts_1.cancel)('Operation cancelled.');
            process.exit(0);
        }
        return packageManager;
    });
    const installDependencies = (installationMethod) => __awaiter(void 0, void 0, void 0, function* () {
        let command;
        if (!installationMethod) {
            let versionManager = detectLockFile();
            if (!versionManager) {
                versionManager = yield promptVersionManager();
            }
            else {
                const shouldContinue = yield (0, prompts_1.confirm)({
                    message: `Lockfile detected for ${versionManager}. Continue with ${versionManager} install?`,
                });
                if (!shouldContinue) {
                    versionManager = yield promptVersionManager();
                }
            }
            switch (versionManager) {
                case 'npm':
                    command = 'npm install --legacy-peer-deps';
                    break;
                case 'yarn':
                    command = 'yarn';
                    break;
                case 'pnpm':
                    command = 'pnpm i --lockfile-only';
                    break;
                default:
                    throw new Error('Invalid package manager selected');
            }
        }
        else {
            command = installationMethod;
        }
        const s = (0, prompts_1.spinner)();
        s.start('⏳ Installing dependencies...');
        try {
            (0, child_process_1.spawnSync)(command, {
                cwd: projectRootPath,
                stdio: 'inherit',
                shell: true,
            });
            s.stop(`\x1b[32mDependencies have been installed successfully.\x1b[0m`);
        }
        catch (err) {
            prompts_1.log.error(`\x1b[31mError: ${err.message}\x1b[0m`);
            prompts_1.log.error('\x1b[31mError installing dependencies:\x1b[0m');
            prompts_1.log.warning(` - Run \x1b[33m'${command}'\x1b[0m manually!`);
            throw new Error('Error installing dependencies.');
        }
    });
    exports.installDependencies = installDependencies;
    const getConfigComponentPath = () => {
        var _a;
        const configFile = fs_extra_1.default.readFileSync(path_1.default.join(currDir, 'gluestack-ui.config.ts'), 'utf-8');
        const match = configFile.match(/componentPath:\s+(['"])(.*?)\1/);
        const componentPath = (_a = (match && match[2])) !== null && _a !== void 0 ? _a : '';
        return componentPath;
    };
    exports.getConfigComponentPath = getConfigComponentPath;
    const addIndexFile = (componentsDirectory, level = 0) => {
        try {
            const files = fs_extra_1.default.readdirSync(componentsDirectory);
            const exports = files
                .filter(file => file !== 'index.js' && file !== 'index.tsx' && file !== 'index.ts')
                .map(file => {
                const stats = fs_extra_1.default.statSync(`${componentsDirectory}/${file}`);
                if (stats.isDirectory()) {
                    if (level === 0) {
                        addIndexFile(`${componentsDirectory}/${file}`, level + 1);
                    }
                    return `export * from './${file.split('.')[0]}';`;
                }
                else {
                    return '';
                }
            })
                .join('\n');
            console.log(componentsDirectory, 'inn utils');
            fs_extra_1.default.writeFileSync(path_1.default.join(componentsDirectory, 'index.ts'), exports);
        }
        catch (err) {
            prompts_1.log.error(`\x1b[31mError: ${err.message}\x1b[0m`);
        }
    };
    exports.addIndexFile = addIndexFile;
    const pascalToDash = (str) => {
        return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    };
    exports.pascalToDash = pascalToDash;
    const dashToPascal = (str) => {
        return str
            .toLowerCase()
            .replace(/-(.)/g, (_, group1) => group1.toUpperCase())
            .replace(/(^|-)([a-z])/g, (_, _group1, group2) => group2.toUpperCase());
    };
    exports.dashToPascal = dashToPascal;
    const checkIfFolderExists = (path) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const stats = yield stat(path);
            return stats.isDirectory();
        }
        catch (error) {
            return false;
        }
    });
    exports.checkIfFolderExists = checkIfFolderExists;
    const wait = (msec) => new Promise((resolve, _) => {
        setTimeout(resolve, msec);
    });
    const tryGitPull = (targetPath) => __awaiter(void 0, void 0, void 0, function* () {
        const git = (0, simple_git_1.default)(targetPath);
        if (fs_extra_1.default.existsSync(targetPath)) {
            try {
                yield git.pull('origin', 'main');
            }
            catch (err) {
                prompts_1.log.error(`\x1b[31mError: ${err.message}\x1b[0m`);
            }
        }
        else {
            prompts_1.log.error('\x1b[31m' + 'Target path does not exist' + '\x1b[0m');
        }
    });
    const pullComponentRepo = (targetpath) => __awaiter(void 0, void 0, void 0, function* () {
        const s = (0, prompts_1.spinner)();
        s.start('⏳ Pulling latest changes...');
        let retry = 0;
        let success = false;
        while (!success && retry < 3) {
            try {
                yield wait(1000);
                yield tryGitPull(targetpath);
                success = true;
            }
            catch (err) {
                prompts_1.log.error(`\x1b[31mError: ${err.message}\x1b[0m`);
                prompts_1.log.error(`\x1b[31mPulling failed - retrying... (Attempt ${retry + 1})\x1b[0m`);
                retry++;
            }
        }
        if (!success) {
            s.stop('\x1b[31m' + 'Pulling failed!' + '\x1b[0m');
        }
        else {
            s.stop('\x1b[32m' + 'Git pull successful.' + '\x1b[0m');
        }
    });
    exports.pullComponentRepo = pullComponentRepo;
    const cloneComponentRepo = (targetPath, gitURL) => __awaiter(void 0, void 0, void 0, function* () {
        const git = (0, simple_git_1.default)();
        const s = (0, prompts_1.spinner)();
        s.start('⏳ Cloning repository...');
        try {
            yield git.clone(gitURL, targetPath);
            s.stop('\x1b[32m' + 'Cloning successful.' + '\x1b[0m');
        }
        catch (err) {
            s.stop('\x1b[31m' + 'Cloning failed' + '\x1b[0m');
            prompts_1.log.error(`\x1b[31mError: ${err.message}\x1b[0m`);
        }
    });
    exports.cloneComponentRepo = cloneComponentRepo;
});
